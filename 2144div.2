//切割数组：https://codeforces.com/contest/2144/problem/A
/*给定一个包含 n 个非负整数的数组 [a₁, a₂, …, aₙ]。你的任务是将它切割成三个非空部分：一个前缀、一个中间部分和一个后缀。形式化地说，你需要选择两个整数 l 和 r，使得 1 ≤ l < r < n，并得到三个部分：

前缀到索引 l 的元素（包含 l），即 [a₁, a₂, …, aₗ]；

中间部分从索引 l+1 到索引 r 的元素（包含 r），即 [aₗ₊₁, aₗ₊₂, …, aᵣ]；

后缀从索引 r+1 到 n 的元素，即 [aᵣ₊₁, aᵣ₊₂, …, aₙ]。

令 s₁, s₂, s₃ 分别是这些部分的和模 3 的余数。换句话说：

s₁ = (∑_{i=1}^l aᵢ) mod 3；

s₂ = (∑_{i=l+1}^r aᵢ) mod 3；

s₃ = (∑_{i=r+1}^n aᵢ) mod 3。

你的任务是找到这样的边界 l 和 r，使得要么所有数 s₁, s₂, s₃ 都不同，要么所有数 s₁, s₂, s₃ 都相同。*/
//我们小学就学过：一些数要能被3整除，那么他们相加要能被3整除，这个是容易想到的，但如何划分仍然是一个问题
/*如果 s₁ + s₂ + s₃ 等于 0 模 3，那么有两种可能的情况：

要么 s₁ = s₂，此时 s₃ 将等于它们（否则它们的和不能被 3 整除）；

或者 s₁ ≠ s₂，那么 s₃ = 3 - s₁ - s₂，并且无论 s₁ 和 s₂ 的值如何，s₃ 都将与它们不同。

因此，如果数组的总和不能被 3 整除，那么就没有合适的切割；如果它能被 3 整除，那么任何切割都是有效的。*/
代码就很容易写出来了：
#include<iostream>
#include<vector>
using namespace std;
void solve()
{
	int n;cin>>n;
	vector<int>a(n);
	int result=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		result+=a[i];
	}
	if(result%3!=0){
		cout<<0<<" "<<0<<endl;
	}else{
		cout<<1<<" "<<2<<endl;
	}
}
int main()
{
	int t;cin>>t;
	while(t--){
		solve();
	}
}
//https://codeforces.com/problemset/problem/2151/C
这个题实在有点意思：（有点难不是）
C. 增量停留时间
你是博物馆的保安。

博物馆的主门既是入口也是出口。每秒最多只能有一个人通过这扇门。有一个传感器可以检测到访客何时通过门。传感器既无法确定访客身份，也无法确定他是进入还是离开博物馆。传感器在2n个不同的时间点a₁, a₂, ..., a₂ₙ（以秒为单位）检测到了一些活动。

对于每个访客，他的停留时间等于离开时间减去进入时间。

目前博物馆已经关闭（所以没有访客），你想知道今天可能的最大总停留时间，即今天所有进入博物馆的访客的停留时间之和的最大可能值。在第0秒时，博物馆也是关闭的。

出于安全原因，博物馆内同时可以容纳的人数也有限制，但你忘记了这个限制。对于每个从1到n的k，你希望确定今天可能的最大总停留时间，假设博物馆内同时最多可以有k个人。

输入
每个测试包含多个测试用例。第一行包含测试用例的数量t（1≤t≤10⁴）。接下来是测试用例的描述。

每个测试用例的第一行包含一个整数n（1≤n≤2×10⁵），表示传感器在2n个不同时间点检测到活动。

每个测试用例的第二行包含2n个整数a₁, a₂, ..., a₂ₙ（1≤a₁<a₂<...<a₂ₙ≤10⁹）——传感器检测到活动的秒数。

保证所有测试用例的n之和不超过2×10⁵。

输出
对于每个测试用例，输出n个整数：对于每个从1到n的k，输出今天可能的最大总停留时间，假设博物馆内同时最多可以有k个人。

示例
输入
3
1
32 78
2
4 5 6 9
4
6149048 26582657 36124499 43993239 813829899 860114890 910238130 913669539

输出
46 
4 6 
78018749 1737022233 1845329695 3385003015 

说明
在第一个测试用例中，传感器在秒数32和78检测到活动。回想一下，k是博物馆内同时可以容纳的最大人数。

如果k是1，最大可能总停留时间是46，当访客1在时间32进入并在时间78离开时达到。

在第二个测试用例中，传感器在秒数4、5、6和9检测到活动。

如果k是1，最大可能总停留时间是4，当访客1在时间4进入并在时间5离开，访客2在时间6进入并在时间9离开时达到。

如果k是2，最大可能总停留时间是6，当访客1在时间4进入并在时间9离开，访客2在时间5进入并在时间6离开时达到。
//题目还是比较好懂的，但是解法我确实没想到是递推
前缀和是想到了，但是递推 emm
但是其实好像cf的题总是会有切入点的，而且切入点其实也就这些
我目前见到的有：从数据与答案的关系退推关系式，这个数据是要根据题目的意思来找的，等下我就放一道今天做的AB题，大概就是这样
一般来说，A题会比较好推一些，而B题可能会涉及到一些取模或者是稍微复杂的关系等问题，但反正你肯定是要往简单或者极端的情况去想，不然肯定想不出
C题的话，一般可能会涉及到一些DP和递推的问题。等我试试看用DP的思想来写
//正文开始：
在前 k 个事件中，有人进入博物馆。在最后 k 个事件中，有人离开博物馆。对于其他事件，如果当前人数为 k，则一人离开；否则，一人进入。
该策略是最优的，因为它最大化博物馆内在任意时刻的人数。//有脑子就行
对于其他事件，在第 i 个事件之后，我们知道人数的奇偶性与 i 的奇偶性相同。实际上，人数要么是 k，要么是 k-1，这是具有正确奇偶性且不超过 k 的最大可能人数。
现在我们需要计算以下项：
1⋅a₁ + 2⋅a₂ + … + k⋅aₖ：可以通过 i⋅aᵢ 的前缀和来计算。//前k项
k⋅a₂ₙ₋ₖ₊₁ + (k-1)⋅a₂ₙ₋ₖ₊₂ + … + 1⋅a₂ₙ：可以通过 (2n - i + 1)⋅aᵢ 的前缀和来计算：//后k项
k⋅(aₖ₊₂ + aₖ₊₄ + … + a₂ₙ₋ₖ)，k⋅(aₖ₊₂ + aₖ₊₄ + … + a₂ₙ₋ₖ₋₁) 以及类似项：可以通过 a₂ᵢ 的前缀和以及 a₂ᵢ₊₁ 的前缀和来计算。
或者，我们可以使用 k-2 的答案并通过修改少数几项来快速计算某个 k 的答案。//这段看完以后，脑子已废
算了，以后再说
AC代码：
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll INF = 1e18;
const ll mod = 998244353;
const int maxn = 110;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    #if !ONLINE_JUDGE && !EVAL
        ifstream fin("input.txt");
        ofstream fout("output.txt");
    #endif

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<ll> v(2 * n);
        for (int i = 0; i < 2 * n; i++) {
            cin >> v[i];
        }

        vector<ll> ans(n + 3, 0);
        
        // Calculate ans[1]
        for (int i = 0; i < 2 * n; i += 2) {
            ans[1] -= v[i];
        }
        for (int i = 1; i < 2 * n; i += 2) {
            ans[1] += v[i];
            ans[2] -= v[i];
        }
        
        // Calculate ans[2]
        for (int i = 2; i < 2 * n; i += 2) {
            ans[2] += v[i];
        }
        ans[2] += 2 * v.back() - v[0];
        
        // Calculate ans[i] for i >= 3 using recurrence relation
        for (int i = 3; i <= n; i++) {
            ans[i] = ans[i - 2] + 2 * (v[v.size() - i + 1] - v[i - 2]);
        }
        
        // Output results
        for (int i = 1; i <= n; i++) {
            cout << ans[i] << " ";
        }
        cout << "\n";
    }

    return 0;
}
