//切割数组：https://codeforces.com/contest/2144/problem/A
/*给定一个包含 n 个非负整数的数组 [a₁, a₂, …, aₙ]。你的任务是将它切割成三个非空部分：一个前缀、一个中间部分和一个后缀。形式化地说，你需要选择两个整数 l 和 r，使得 1 ≤ l < r < n，并得到三个部分：

前缀到索引 l 的元素（包含 l），即 [a₁, a₂, …, aₗ]；

中间部分从索引 l+1 到索引 r 的元素（包含 r），即 [aₗ₊₁, aₗ₊₂, …, aᵣ]；

后缀从索引 r+1 到 n 的元素，即 [aᵣ₊₁, aᵣ₊₂, …, aₙ]。

令 s₁, s₂, s₃ 分别是这些部分的和模 3 的余数。换句话说：

s₁ = (∑_{i=1}^l aᵢ) mod 3；

s₂ = (∑_{i=l+1}^r aᵢ) mod 3；

s₃ = (∑_{i=r+1}^n aᵢ) mod 3。

你的任务是找到这样的边界 l 和 r，使得要么所有数 s₁, s₂, s₃ 都不同，要么所有数 s₁, s₂, s₃ 都相同。*/
//我们小学就学过：一些数要能被3整除，那么他们相加要能被3整除，这个是容易想到的，但如何划分仍然是一个问题
/*如果 s₁ + s₂ + s₃ 等于 0 模 3，那么有两种可能的情况：

要么 s₁ = s₂，此时 s₃ 将等于它们（否则它们的和不能被 3 整除）；

或者 s₁ ≠ s₂，那么 s₃ = 3 - s₁ - s₂，并且无论 s₁ 和 s₂ 的值如何，s₃ 都将与它们不同。

因此，如果数组的总和不能被 3 整除，那么就没有合适的切割；如果它能被 3 整除，那么任何切割都是有效的。*/
代码就很容易写出来了：
#include<iostream>
#include<vector>
using namespace std;
void solve()
{
	int n;cin>>n;
	vector<int>a(n);
	int result=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		result+=a[i];
	}
	if(result%3!=0){
		cout<<0<<" "<<0<<endl;
	}else{
		cout<<1<<" "<<2<<endl;
	}
}
int main()
{
	int t;cin>>t;
	while(t--){
		solve();
	}
}
